
适配器模式是什么？

我的理解：
比如现实世界，电脑充电需要的电压是12V，而家用电压是220V，肯定不能直接用呀，那不就炸了呀。所以我们需要一个”中间设备“，将220V电压转为12V，这个“中间设备”就叫做Adapter适配器。
好了，以上就出现3个角色了：
1. 所需电压（12V）
2. 适配器
3. 现有电压（220V）

为什么要有适配器模式？
我的理解：
在不改变现有程序的情况下，通过创建一个适配器，去扩展我们所需的程序。


先用一个例子来看看代码的实现
1. 我们需要打印一个字符串，所需接口是Print，他有两个方法，分别是printWeak弱显示（将字符串用括号括起来），强显示printStrong（将字符串用*括起来）
```java
public interface Print {
    public void printWeak();
    public void printString();
}
```
2. 巧了我们现在有一个现成的类Banner，他里面刚好有这两个方法，但是他们方法名不一样，分别是showWithParen和showWithAster，我们很想用，但是没办法直接用，总不可能把现有的类的方法名给改了吧。
```java
public class Banner {
    private String string;

    public Banner(String string) {
        this.string = string;
    }

    public void showWithParen() {
        System.out.println("(" + string + ")");
    }

    public void showWithAster() {
        System.out.println("*" + string + "*");
    }
}
```
3. 所以需要一个适配器PrintBanner，他实现了接口Print，又继承了Banner，在实现接口方法里面直接用Banner的方法就好啦。
```java
public class PrintBanner extends Banner implements Print {
    public PrintBanner(String string) {
        super(string);
    }

    @Override
    public void printWeak() {
        showWithParen();
    }

    @Override
    public void printString() {
        showWithAster();
    }
}
```

上面这种属于类适配器模式（使用继承的适配器）。
有一种情况是，当Print不是接口，而是抽象类怎么办呢，PrintBanner不能继承两个父类呀，这时候就可以用下面方式解决：
1. Print接口改为abstract类
```java
public abstract class Print {
    public abstract void printWeak();
    public abstract void printString();
}

```
2. PrintBanner类只继承Print，然后将Banner作为成员属性“组合”进来
```java
public class PrintBanner extends Print{

    private Banner banner;

    public PrintBanner(String string) {
        banner = new Banner(string);
    }

    @Override
    public void printWeak() {
        banner.showWithParen();
    }

    @Override
    public void printString() {
        banner.showWithAster();
    }
}
```

这样Banner和Main都不用改变，一样可以实现适配器模式。从以上两种方式都可以看出，他们的本质都是一样的，都**在不改变现有程序（Banner）**的情况下，使用适配器（PrintBanner）去扩展，以便成为我们所需的程序。


用于填补“现有程序”和“所需程序”之间差异的设计模式就是Adapter模式，也称为Wrapper模式。
Adapter模式有两种：
1. 类适配器模式（使用继承的适配器）
2. 对象适配器模式（使用委托的适配器）



