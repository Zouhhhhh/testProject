





## 一、一对多列表，新增和移除



（1）首先分为两组数据，一组新数据，一组旧数据



（2）判断新数据是否为空，如是，则旧数据全部清除



（3）新数据不为空，先清除旧数据（遍历旧数据，若newDatas.contain(oldItem)为false，则oldItem.deleted = true;）



（4）再增加新数据（遍历新数据，若oldDatas.contain(newItem)为false，执行sql脚本新增 newItem）



（5）dao.persistOrMerge(oldDatas);





## 二、类似深拷贝实体（包括里面的一对多）

有这样一个实体A，里面有很多的一对多，每个一对多也可能有它的一对多。现在要把这样一棵实体树全部复制一份。

![1642212883631](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1642212883631.png)



首先想到的是广度优先搜索bfs，先看看这算法咋用



BFS用到一个队列来存储节点，比如A最先入队，开始循环

（1）queue是否为空，不为空去（2）

（2）A出队，它的儿子依次入队，输出A

（4）现在队列情况（FEDCB）

（5）B出队，没有儿子，输出B

。。。

（6）D出队，它的儿子依次入队，输出D

（7）现在队列情况（HGFE）



差不多就是这样，代码如下（二叉树为例）

```java
public void bfs(TreeNode root) {
    if (root == null) return void;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (queue.size() > 0) {
        TreeNode node = queue.poll();
        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
        System.out.println(node.val);
    }
}
```



回归到上面实体复制的场景，就是

```java
public void bfs(Object root, String suffix) {
    if (!hasOneToMany(root)) {
        copy(root);
        return void;
    }
    Queue<Object> queue = new LinkedList<>();
    queue.offer(root);
    while (queue.size() > 0) {
        Object node = queue.poll();
        
        //是否有一对多
        if(hasOneToMany(node)) {
            List<List<Object>> oneToManyList = getOneToMany(node);
            //入队
            oneToManyList.foreach(oneToMany -> {
                oneToMany.foreach(item -> {
                   queue.offer(item); 
                });
            });
        }
        
        //复制
        copy(node, suffix);
    }
}

public boolean hasOneToMany(Object o)  //用来判断是否有一对多

public List<List<Object>> getOneToMany(Object o)	//用来获取对象的一对多
    
public void copy(Object o, String suffix)	//用来复制单个对象，新对象的ID为（旧ID+suffix）
    

```

