
迭代器模式是什么？
1. 就是有一个有序集合（比如数组），我们既可以按顺序从集合中拿出每个”位置“对应的数据，也可以指定拿出某个“位置”的数据。（这个“位置”可以是java中的循环变量i），当我们把这个“位置”的作用抽象化，通用化之后形成的模式，就叫做迭代器模式（iterator）。
2. 迭代器模式用于在数据集合中按照”顺序“（这里的”顺序“也可以是跳跃式访问）遍历集合。所以说，这里的迭代器作用更加单一了，他要么是按顺序访问，要么是指定”位置“访问。

为什么要有迭代器模式？
1. 书本的解释：一个重要的理由是，引入iterator后可以将**遍历**与**实现**分离开来。
2. 我的理解就是 将这样一种访问数据集合的方式，形成一种单一作用的模式，并且指出哪些集合实现了这种模式，消除调用它们的差异，而分离他们具体实现的特点（比如集合1是顺序访问，集合2是逆序访问，但是我们可以通过一样的模式去”访问“就行了，不用管他们的访问是怎么实现的，我们只要拿到他们各自的iterator，然后先问是不是有下一个，有就拿，没有就结束），以便于我们利用这种模式去通用化地访问数据集合。

再来看代码：
1. 首先有这样一个集合接口Aggregate，表示实现了这个接口的集合，都拥有这种访问集合模式，即他们都会有一个iterator
```java
public interface Aggregate {
    public Iterator iterator();
}
```
2. 然后再有iterator这样一个接口，表示抽象的迭代器，他有两个方法去共同实现一种访问集合的方式，但是具体怎么访问，不知道，要看具体的实现类。
```java
public interface Iterator {
    public boolean hasNext();
    public Object next();
}
```
3. 好了，接下来看具体实现类，有这样一个集合BookShelf，他可以装了很多的Book，并且实现了接口Aggregate，所以他有一个自己专属的迭代器BookShelfIterator
```java
public class BookShelf implements Aggregate{
    private List<Book> books = new ArrayList<>(1);

    public int getLength() {
        return books.size();
    }

    public void appendBook(Book book) {
        books.add(book);
    }

    public Book getBookAt(int index) {
        return books.get(index);
    }

    @Override
    public Iterator iterator() {
        return new BookShelfIterator(this);
    }
}

public class Book {
    private String bookName;

    public Book(String bookName) {
        this.bookName = bookName;
    }

    public String getBookName() {
        return bookName;
    }
}
```
4. 专属的迭代器BookShelfIterator
```java
public class BookShelfIterator implements Iterator {

    private BookShelf bookShelf;

    private int index;

    public BookShelfIterator(BookShelf bookShelf) {
        this.bookShelf = bookShelf;
        this.index = 0;
    }

    @Override
    public boolean hasNext() {
        return index < this.bookShelf.getLength();
    }

    @Override
    public Object next() {
        Object next = bookShelf.getBookAt(this.index);
        this.index++;
        return next;
    }
}
```
5. 来看下怎么“访问”这个BookShelf集合吧
```java
public class Main {
    public static void main(String[] args) {
        BookShelf bookShelf = new BookShelf();
        bookShelf.appendBook(new Book("book1"));
        bookShelf.appendBook(new Book("book2"));
        bookShelf.appendBook(new Book("book3"));

        Iterator bookShelfIterator = bookShelf.iterator();
        while (bookShelfIterator.hasNext()) {
            Book book = (Book) bookShelfIterator.next();
            System.out.println(book.getBookName());
        }
    }
}
```

可以看到，我们首先准备好这个集合，放了三本Book进去，然后拿到BookShelf的迭代器iterator，用iterator里面的方法去“访问”集合，但是具体怎么访问的，不知道。不知道的好处就是，他可以是顺序访问，也可以是逆序访问，随时改iterator的实现就好了，作为调用者的我们不用管，只知道可以访问就行了。

而且，iterator模式的访问方法相对固定，一般都是先while判断是不是hasNext()，有的话就通过next()去拿。