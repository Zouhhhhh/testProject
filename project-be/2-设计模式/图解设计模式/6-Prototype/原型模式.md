
## 原型模式是什么？
Prototype模式：不根据类来生成实例，而是根据实例来生成新实例。

怎么理解呢？举个例子，就是比如现在我们只有两个类，球（Ball）和盒子（Box），它们都有一个属性是颜色，但是现在我不想每次创建一个新的球和盒子，都要赋值好是什么颜色的，我只想要说，红色的球或者蓝色的盒子，你直接创建好这样的对象给我。

那要怎么做呢？重点就是要有一个HashMap<String, Product>，key就是实例名，比如redBall或者blueBox，然后value就是我们一开始new好的对象，以它们作为**原型**，用来生成新的对象。

好了，原型有了，还有另一个重点就是怎么创建呢？这就需要全部的**原型**对象所在的类，都实现一个接口，拥有共同的创建方式（克隆clone）

来看看代码，这里用的例子是有两个类，分别将输入的字符串用下划线或一些字符框起来，但是至于用什么作为下划线和框起来的字符，就是各种的**原型**了。
1. 管理**原型**的类
```java
public class Manager {
    private HashMap showcase = new HashMap();

    public void register(String name, Product proto) {
        showcase.put(name, proto);
    }

    public Product create(String protoname) {
        Product p = (Product) showcase.get(protoname);
        return p.createClone();
    }
}
```

2. 抽象原型，有复制和使用的方法
```java
public interface Product extends Cloneable{
    public abstract void use(String s);
    public abstract Product createClone();
}
```


3. 具体类，用来初始化一些具体**原型**对象

用类似* 和 /的字符 将输入的字符串框起来
```java
public class MessageBox implements Product {

    private char decochar;

    public MessageBox(char decochar) {
        this.decochar = decochar;
    }

    @Override
    public void use(String s) {
        int length = s.getBytes().length;
        for (int i = 0; i < length + 4; i++) {
            System.out.print(decochar);
        }
        System.out.println("");
        System.out.println(decochar + " " + s + " " + decochar);
        for (int i = 0; i < length + 4; i++) {
            System.out.print(decochar);
        }
        System.out.println("");
    }

    @Override
    public Product createClone() {
        Product p = null;
        try {
            p = (Product) clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return p;
    }
}
```

用 类似~ 的字符作为下划线
```java
public class UnderLinePen implements Product {
    private char ulchar;

    public UnderLinePen(char ulchar) {
        this.ulchar = ulchar;
    }

    @Override
    public void use(String s) {
        int length = s.getBytes().length;
        System.out.println(s);
        for (int i = 0; i < length; i++) {
            System.out.print(ulchar);
        }
        System.out.println("");
    }

    @Override
    public Product createClone() {
        Product p = null;
        try {
            p = (Product) clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return p;
    }
}

```

## 为什么要用原型模式？
1. 对象种类繁多，无法将他们整合到一个类中时
2. 难以根据类生成实例时
3. 想解耦框架与生成的实例时

