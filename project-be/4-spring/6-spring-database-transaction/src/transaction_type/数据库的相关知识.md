

## 1. 数据库事务ACID特性
- 原子性（Atomicity）：要么都完成，要么都不完成。
- 一致性（Consistency）：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。
- 隔离性（Isolation）：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。
- 持久性（Durability）：指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。

事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用**日志**来保证事务的**原子性、一致性和持久性**。数据库管理系统采用**锁机制**来实现事务的**隔离性**。


## 2. 隔离级别
在关系型数据库中，事务的隔离性分为四个隔离级别，在解读这四个级别前先介绍几个关于读数据的概念。
- 1）脏读（Dirty Reads）：所谓脏读就是对脏数据（Drity Data）的读取，而脏数据所指的就是未提交的数据。也就是说，一个事务正在对一条记录做修改，在这个事务完成并提交之前，这条数据是处于待定状态的（可能提交也可能回滚），这时，第二个事务来读取这条没有提交的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被称为脏读。（oracle通过undo日志保证，读未提交的数据时，放回undo后的数据）
- 2）不可重复读（Non-Repeatable Reads）：一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。也就是说，这个事务在两次读取之间该数据被其它事务所修改。
- 3）幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。


事务四个隔离级别对比：

1）未提交读（Read Uncommitted）：SELECT语句以非锁定方式被执行，所以有可能读到脏数据，隔离级别最低。（读不锁）

2）提交读（Read Committed）：只能读取到已经提交的数据。即解决了脏读，但未解决不可重复读。（读锁，等写完）

3）可重复读（Repeated Read）：在同一个事务内的查询都是事务开始时刻一致的，InnoDB的默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。(写锁，等读完)

4）串行读（Serializable）：完全的串行化读，所有SELECT语句都被隐式的转换成SELECT ... LOCK IN SHARE MODE，即读取使用表级共享锁，读写相互都会阻塞。隔离级别最高。(以上3个均为行锁/记录锁，当前为表锁)


## 3. 传播特性

| 传播行为      | 含义                                                         | 备注                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| REQUIRED      | 如果不存在当前事务，那么就创建事务，如果之前的方法已经存在事务，就沿用 | 这是Spring默认的传播行为                                     |
| SUPPORTS      | 如果不存在当前事务，那么就不启用事务，如果存在，就沿用       |                                                              |
| MANDATORY     | 方法必须在事务内运行                                         | 如果不存在事务，就抛出异常                                   |
| REQUIRES_NEW  | 无论是否存在当前事务，方法都会在新的事务中运行               | 也就是事务管理器会打开新的事务运行该方法                     |
| NOT_SUPPORTED | 不支持事务，如果不存在当前事务也不会创建，如果存在当前事务，则挂起它，直至该方法结束后才恢复当前事务 | 适用于那些不需要事务的SQL                                    |
| NEVER         | 不支持事务，只有在没有事务的环境才能运行它                   | 如果方法存在当前事务，则抛出异常                             |
| NESTED        | 嵌套事务，也就是调用方法如果抛出异常只回滚自己内部执行的SQL，而不回滚主方法的SQL | 它的实现存在两种情况，如果当前数据库支持保存点（savepoint），那么它就会在当前事务上使用保存点技术。如果发生异常则将方法内执行的SQL回滚到保存点上，而不是全部回滚，否则就等同于REQUIRES_NEW创建新的事务运行方法代码 |

