

## 工厂方法模式是什么？

前面说了，模板方法模式就是在父类中定义处理流程的方法，而在子类具体实现。那么将模板方法模式用于生成实例，这种模式就叫工厂方法模式。

我的理解是：就是在父类定义好生成实例的通用流程（先创建，再注册“产品”），再把创建和注册的具体实现作为抽象方法给各个子类实现，这样就能让子类都调用同一套逻辑（父类的方法）去生成实例了。这里还需要用到另外一个角色“产品”。

## 为什么要用工厂方法模式？
同样的，使用工厂方法模式可以使得**定义**与**实现**分离，我们只在父类中定义了这样一套生成实例的流程，但是具体怎么实现的，不知道，都交给子类了。而且，不用new关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类的耦合。


## 再看代码
抽象父类，用于定义通用流程，以及两个抽象方法供子类实现
```java
public abstract class Factory {

    public final Product create(String owner) {
        Product p = createProduct(owner);
        registerProduct(p);
        return p;
    }

    public abstract Product createProduct(String owner);
    public abstract void registerProduct(Product p);
}
```

抽象产品，用于定义子类创建的实例（产品） 所拥有的共用特性（可以use）
```java
public abstract class Product {
    public abstract void use();
}
```

以上都是作为框架包中的内容，一般写好了之后很少改动，需要增加或改动的都是在子类中。

具体工厂，生成ID卡
```java
public class IDCardFactory extends Factory {

    private List owners = new ArrayList<>();

    @Override
    public Product createProduct(String owner) {
        return new IDCard(owner);
    }

    @Override
    public void registerProduct(Product p) {
        owners.add(((IDCard) p).getName());
    }

    public List<IDCard> getIdCardList() {
        return owners;
    }
}
```

具体产品，ID卡，继承了抽象产品，也有use方法。
```java
public class IDCard extends Product {
    private String name;
    IDCard(String name) {
        System.out.println("制作ID卡： " + name);
        this.name = name;
    }

    @Override
    public void use() {
        System.out.println("使用ID卡： " + name);
    }

    public String getName() {
        return name;
    }

}
```

测试一下
```java
public class Test {
    public static void main(String[] args) {
        Factory factory = new IDCardFactory();
        Product card1 = factory.create("小明");
        Product card2 = factory.create("小红");
        Product card3 = factory.create("小刚");
        card1.use();
        card2.use();
        card3.use();
    }
}
```

