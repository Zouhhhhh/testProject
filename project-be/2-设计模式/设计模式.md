- JDK动态代理和责任链模式
	在java中有多种动态代理技术，比如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术有两种：一种是JDK动态代理，这是JDK自带的功能；另一种是CGLIB，这是第三方提供的一个技术。目前，Spring常用JDK和CGLIB，而MyBatis还试用了Javassist。这里讲JDK（必须使用接口）和CGLIB（不需要接口）。
	- JDK动态代理
		案例：重点是代理类要实现InvocationHandler接口，重写invoke方法，并与真实对象进行绑定bind（通过Proxy.newProxyInstance方法建立并生成代理对象），以达到调用真实对象时，触发操作前后的动作
	- CGLIB动态代理
		案例：与JDK代理类似，只是不需要真实对象实现某个接口。在真实对象和代理对象之间存在桥梁（cglib增强类对象Enhancer），通过为增强类对象设置增强类型setSuperclass（真实对象的类对象Class），定义代理逻辑对象setCallback(代理对象this，要求实现MethodInterceptor接口)，并返回代理对象create()
- 拦截器
	由于动态代理一般都比较难理解，程序设计者会设计一个拦截器接口供开发者使用，开发者只要知道拦截器接口的方法、含义和作用即可，无须知道动态代理是怎么实现的JDK动态代理来实现个拦截器的逻辑，为此先定义拦截器接口Interceptor。

	我的理解：其实和JDK动态代理是类似的，只是将代理对象的invoke方法中操作前后的逻辑分离出来，放到拦截器中的before、around、after方法中。在调用真实对象时，触发代理对象中的拦截器的这些方法，实现操作前后逻辑。

- 责任链模式（chain of responsibility pattern）
	上述讲到将代理对象的操作前后逻辑分离出来，放到一个拦截器中。但是这里就可能存在问题：拦截器可能有多个。当一个对象在一条链上被多个拦截器拦截处理（拦截器也可以选择不拦截处理它）时，我们把这样的设计模式成为责任链模式。
	
- 案例：类似于上述拦截器的案例，只是加多两个拦截器。一共产生3个代理对象，前两个代理对象依次作为真实对象继续与代理对象绑定bind。调用真实方法时，会从第三个代理对象的before方法开始，从第一个代理对象的after方法依次调用。
	
- 观察者模式
	观察者模式又称为发布订阅模式，是对象的行为模式。观察者模式定义了一种一对多的依赖关系，让多个观察者同时监视着被观察者的状态，当被观察者的状态发生变化时，会通知所有观察者，并让其自动更新自己。
	
	涉及类：
		- ProductList
		继承了Obserable类表明是一个被观察者，可以通过父类的addObserver方法去增加它的观察者，并通过this.setChanged()和this.notifyObservers(newProduct);告知观察者，状态已发生改变。
		- JingDongObserver和TaoBaoObserver，实现了Observer接口，重写update方法，表明是观察者，当被观察者调用notifyObservers(args)方法时，会循环调用所有观察者的这个update方法。
	注：上面很多方法都过时了，可以用java.bean的PropertyChangeSupport和PropertyChangeListener替代

- 建造者模式（Builder）
	Builder是一种分步构建对象的模式。