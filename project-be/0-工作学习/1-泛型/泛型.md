# 泛型



## 一、为什么要使用泛型



## 二、泛型类



## 三、泛型方法



## 四、类型变量的限定



## 五、泛型与虚拟机

### 5.1 类型擦除

虚拟机没有泛型类型对象，所有对象都属于普通类。

无论何时定义一个泛型类型，都会自动提供一个相应的原始类型（raw type）。类型变量会被擦除（erased），并替换为其限定类型（或者，对于无限定的变量则替换为Object）。

### 5.2 转换泛型表达式

``` java
Pair<Employee> buddies = ...;
Employee buddy = buddies.getFirst();
```

getFirst擦除类型后的返回类型是Object，编译器自动插入转换到Employee的强制类型转换。

### 5.3 转换泛型方法

类型擦除也会出现在泛型方法中

```java
public static <T extends Comparable> T min(T[] a)
// 转换后
public static Comparable min(Comparable[] a)
```



但是会有这样一种情况，父类Pair<T>是泛型类，子类DateInterval继承了Pair<LocalDate>，子类重写了父类的setSecond(LocalDate)方法。类型擦除后，子类变成有两个setSecond方法了，一个是重写的setSecond(LocalDate)，另一个是父类的setSecond(Object)，会认为是两个不同的方法了，所以在“多态”时会有问题。如

``` java
var interval = new DateInterval(...);
Pair<LocalDate> pair = interval;	// 父类引用指向子类对象
pair.setSecond(aDate);		// 调用重写的方法
```

这里类型擦除与多态发生了冲突，为了解决这个问题，编译器在DateInterval类中生成一个桥方法（bridge method）

``` java
public void setSecond(Object) {
    setSecond((LocalDate) objet);
}
```







## 六、通配符（重要）

首先搞清楚一点，通配符<?>是用来作为“类型参数”，而不是“类型变量”的。

``` java
// error
class Pair<? extends Employee> {  
}
```

``` java
// right
public static void printBuddies(Pair<? extends Employee> p) {
    ...
}
```



为什么要有通配符呢？或者说通配符的出现是用来解决什么问题的？

因为严格的泛型类型用起来没那么方便。。。比如想要定义一个方法，参数是Pair<Employee>，那么它就不能接收Pair<Manager>类型的。所以就有了通配符<?>















