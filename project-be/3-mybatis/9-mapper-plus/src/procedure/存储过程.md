
首先创建好一个存储过程

``` sql
CREATE DEFINER=`root`@`localhost` PROCEDURE `count_role`(
    in p_role_name varchar(255),
    out count_total int(8),
    out exec_date date )
BEGIN
    SELECT COUNT(*) INTO count_total FROM t_role WHERE role_name LIKE concat("%", p_role_name, "%");
    SELECT now() INTO exec_date;
END &&
```
1. 一个入参p_role，一个出参count_total，一个出参exec_date。 这个存储过程的目的是通过入参（角色名称），模糊查询匹配的条数，以及输出查询时间

2. 然后设置好一个pojo类作为参数类PdCountRoleParams
``` java
public class PdCountRoleParams {
    private String roleName;
    private Integer total;
    private Date execDate;
    
    // getting和setting
}
```

3. 在RoleMapper.xml中定义好select标签
```xml
    <!-- 存储过程 -->
    <!-- 这里有个坑，mybatis的存储过程不支持二级缓存，所以需要把外部的<cache/>关掉，或者这里设置useCache -->
    <select id="countRole" parameterType="pdCountRoleParams" statementType="CALLABLE" useCache="false">
        {call count_role(
                #{roleName, mode=IN, jdbcType=VARCHAR},
                #{total, mode=OUT, jdbcType=INTEGER},
                #{execDate, mode=OUT, jdbcType=DATE}
            )}
    </select>
```

4. 然后测试类试一下，调用RoleMapper的countRole方法，并创建好一个PdCountRoleParams传入，执行完存储过程后就能从参数类对象中拿到out变量
```java
    sqlSession = SqlSessionFactoryUtils.openSqlSession();
    RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);
    roleMapper.countRole(params);
    params.getTotal();
    params.getExecDate();
```

